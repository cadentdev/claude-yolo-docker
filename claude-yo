#!/bin/bash

# Parse arguments
# Wrapper flags are parsed here; all other arguments pass through to Claude Code.
# Wrapper flags (-r, -v, -d, -h) are intentionally chosen to avoid collision with
# Claude Code's flags (which use long-form like --model, --allowedTools, etc.)
REBUILD=false
VERBOSE=false
DEBUG=false
HEADLESS=false
CLAUDE_ARGS=()

for arg in "$@"; do
  case $arg in
    -h|--help)
      echo "Usage: claude-yo [OPTIONS] [-- CLAUDE_ARGS...]"
      echo ""
      echo "Run Claude Code in an isolated Docker container with YOLO mode enabled."
      echo ""
      echo "Wrapper Options:"
      echo "  -r, --rebuild    Force rebuild of Docker image from scratch (clears cache)"
      echo "  -v, --verbose    Enable verbose mode with full session logging"
      echo "  -d, --debug      Enable debug mode with persistent container shell"
      echo "  --headless       Run without TTY (for cron/automation)"
      echo "  -h, --help       Display this help message"
      echo ""
      echo "Any unrecognized arguments are passed directly to Claude Code."
      echo "Wrapper flags are chosen to avoid collision with Claude Code's flags."
      echo ""
      echo "The container will mount your current directory as the workspace."
      echo "Authentication data persists across runs in a Docker volume."
      echo ""
      echo "Per-Project Customization:"
      echo "  Create a .claude-yo.yml file in your project root to install additional tools:"
      echo ""
      echo "    base: node:20-bookworm-slim  # Custom base image (optional)"
      echo "    apt:                    # System packages"
      echo "      - git"
      echo "    pip:                    # Python packages (Python 3.12 included by default)"
      echo "      - pytest"
      echo "    npm:                    # Global npm packages"
      echo "      - typescript"
      echo "    run:                    # Custom commands"
      echo "      - \"echo hello\""
      echo ""
      echo "  Use 'base:' for Node.js-only projects to skip Python overhead."
      echo ""
      echo "Examples:"
      echo "  claude-yo                                    # Fast workflow (default)"
      echo "  claude-yo --verbose                          # Full session logging"
      echo "  claude-yo --debug                            # Persistent shell for exploration"
      echo "  claude-yo --debug --verbose                  # Persistent shell + full logging"
      echo "  claude-yo --headless -p \"Run tests\"          # Non-interactive (cron/CI)"
      echo "  claude-yo --rebuild                          # Update to latest Claude Code"
      echo "  claude-yo -p \"Review the README\"             # Pass a prompt to Claude"
      echo "  claude-yo --model sonnet                     # Use a specific model"
      echo "  claude-yo -d -p \"Fix the tests\" --model opus # Combine wrapper and Claude flags"
      echo ""
      echo "All sessions are logged to: ~/.claude-yolo/logs/claude-yolo-TIMESTAMP.log"
      echo "For detailed mode documentation, see the README.md file."
      exit 0
      ;;
    -r|--rebuild)
      REBUILD=true
      ;;
    -v|--verbose)
      VERBOSE=true
      ;;
    -d|--debug)
      DEBUG=true
      ;;
    --headless)
      HEADLESS=true
      ;;
    *)
      # Pass unrecognized arguments to Claude Code
      CLAUDE_ARGS+=("$arg")
      ;;
  esac
done

# Validate flag combinations
if [ "$HEADLESS" = true ] && [ "$DEBUG" = true ]; then
  echo "Error: --headless and --debug are mutually exclusive"
  exit 1
fi

# Build the Claude command with any passthrough arguments
CLAUDE_CMD="claude --dangerously-skip-permissions"
if [ ${#CLAUDE_ARGS[@]} -gt 0 ]; then
  # Join args with proper quoting for the command
  for arg in "${CLAUDE_ARGS[@]}"; do
    CLAUDE_CMD="$CLAUDE_CMD $(printf '%q' "$arg")"
  done
fi

# Setup logging
LOG_DIR="$HOME/.claude-yolo/logs"
mkdir -p "$LOG_DIR"
TIMESTAMP=$(date +%Y-%m-%d-%H%M%S)
LOGFILE="$LOG_DIR/claude-yolo-$TIMESTAMP.log"

# Record start time for execution tracking
START_TIME=$(date +%s)

# Log function for wrapper messages
log_message() {
  echo "$@" | tee -a "$LOGFILE"
}

# Format elapsed time as human-readable string
format_elapsed_time() {
  local elapsed=$1
  local hours=$((elapsed / 3600))
  local minutes=$(((elapsed % 3600) / 60))
  local seconds=$((elapsed % 60))

  if [ $hours -gt 0 ]; then
    echo "${hours}h ${minutes}m ${seconds}s"
  elif [ $minutes -gt 0 ]; then
    echo "${minutes}m ${seconds}s"
  else
    echo "${seconds}s"
  fi
}

# Log execution time on exit
log_execution_time() {
  local end_time=$(date +%s)
  local elapsed=$((end_time - START_TIME))
  local formatted=$(format_elapsed_time $elapsed)
  log_message "Completed in $formatted"
}

# Set trap to log execution time on exit
trap log_execution_time EXIT

# =============================================================================
# Per-Project Configuration Functions
# =============================================================================

# Validate config file syntax and security
validate_config() {
  local config_file="$1"

  # Check YAML syntax using yq in a container
  if ! docker run --rm -v "$config_file:/config.yml:ro" claude-yolo:latest yq '.' /config.yml > /dev/null 2>&1; then
    log_message "Error: Invalid YAML syntax in .claude-yo.yml"
    return 1
  fi

  # Validate package names don't contain dangerous characters
  local content
  content=$(cat "$config_file")
  if echo "$content" | grep -qE '[;&|`$]'; then
    log_message "Error: Invalid characters in .claude-yo.yml (shell metacharacters not allowed)"
    return 1
  fi

  return 0
}

# Generate project-specific Dockerfile
generate_project_dockerfile() {
  local config_file="$1"
  local output_file="$2"

  # Check if custom base image is specified (strip quotes and whitespace)
  local base_image
  base_image=$(docker run --rm -v "$config_file:/config.yml:ro" claude-yolo:latest yq '.base // ""' /config.yml 2>/dev/null | tr -d '\n"'"'")

  if [ -n "$base_image" ]; then
    # Custom base image - need to install Node.js and Claude Code
    {
      echo "FROM $base_image"
      echo ""
      echo "# Install Node.js and Claude Code (required for claude-yo)"
      echo "RUN apt-get update && \\"
      echo "    apt-get install -y curl yq && \\"
      echo "    curl -fsSL https://deb.nodesource.com/setup_20.x | bash - && \\"
      echo "    apt-get install -y nodejs && \\"
      echo "    rm -rf /var/lib/apt/lists/* && \\"
      echo "    npm install -g @anthropic-ai/claude-code"
      echo ""
    } > "$output_file"
  else
    # No custom base - extend the pre-built claude-yolo image
    echo "FROM claude-yolo:latest" > "$output_file"
    echo "" >> "$output_file"
  fi

  # apt packages
  local apt_packages
  apt_packages=$(docker run --rm -v "$config_file:/config.yml:ro" claude-yolo:latest yq '.apt[]' /config.yml 2>/dev/null | tr '\n' ' ')
  if [ -n "$apt_packages" ]; then
    echo "RUN apt-get update && apt-get install -y $apt_packages && rm -rf /var/lib/apt/lists/*" >> "$output_file"
  fi

  # pip packages
  local pip_packages
  pip_packages=$(docker run --rm -v "$config_file:/config.yml:ro" claude-yolo:latest yq '.pip[]' /config.yml 2>/dev/null | tr '\n' ' ')
  if [ -n "$pip_packages" ]; then
    echo "RUN pip3 install --break-system-packages $pip_packages" >> "$output_file"
  fi

  # npm packages
  local npm_packages
  npm_packages=$(docker run --rm -v "$config_file:/config.yml:ro" claude-yolo:latest yq '.npm[]' /config.yml 2>/dev/null | tr '\n' ' ')
  if [ -n "$npm_packages" ]; then
    echo "RUN npm install -g $npm_packages" >> "$output_file"
  fi

  # Custom RUN commands
  docker run --rm -v "$config_file:/config.yml:ro" claude-yolo:latest yq '.run[]' /config.yml 2>/dev/null | while read -r cmd; do
    if [ -n "$cmd" ]; then
      echo "RUN $cmd" >> "$output_file"
    fi
  done

  echo "" >> "$output_file"
  echo "WORKDIR /workspace" >> "$output_file"
}

# Get project image name from directory
get_project_image_name() {
  local mount_dir="$1"
  local project_name
  project_name=$(basename "$mount_dir" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g')
  echo "claude-yolo-project:$project_name"
}

# Get config hash for cache invalidation
get_config_hash() {
  local config_file="$1"
  if command -v sha256sum &> /dev/null; then
    sha256sum "$config_file" 2>/dev/null | cut -c1-8
  elif command -v shasum &> /dev/null; then
    shasum -a 256 "$config_file" 2>/dev/null | cut -c1-8
  else
    # Fallback: use file modification time
    stat -f %m "$config_file" 2>/dev/null || stat -c %Y "$config_file" 2>/dev/null
  fi
}

# =============================================================================

# Get host user info
USERID=$(id -u)
GROUPID=$(id -g)
USERNAME=$(whoami)
MOUNTDIR=$(pwd)
# Resolve symlinks to find the actual script directory (where Dockerfile lives)
SCRIPT_SOURCE="$0"
while [ -L "$SCRIPT_SOURCE" ]; do
  SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_SOURCE")" && pwd)"
  SCRIPT_SOURCE="$(readlink "$SCRIPT_SOURCE")"
  # Handle relative symlinks
  [[ "$SCRIPT_SOURCE" != /* ]] && SCRIPT_SOURCE="$SCRIPT_DIR/$SCRIPT_SOURCE"
done
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_SOURCE")" && pwd)"

# Notify user of log location
log_message "Session log: $LOGFILE"

# =============================================================================
# Build Logic - Base Image and Project-Specific Images
# =============================================================================

# Configuration file path
CONFIG_FILE="$MOUNTDIR/.claude-yo.yml"
DOCKER_IMAGE="claude-yolo:latest"

# Handle rebuild or normal build of base image
if [ "$REBUILD" = true ]; then
  log_message "Removing existing base image..."
  docker rmi claude-yolo:latest 2>&1 | tee -a "$LOGFILE" || true
  log_message "Building base image from scratch (no cache)..."
  if ! docker build --no-cache -t claude-yolo:latest "$SCRIPT_DIR" 2>&1 | tee -a "$LOGFILE"; then
    log_message "Error: Docker build failed. Please check the error messages above."
    exit 1
  fi
  log_message "Base image build complete!"
elif [[ "$(docker images -q claude-yolo:latest 2> /dev/null)" == "" ]]; then
  log_message "Building Docker base image (first run only)..."
  if ! docker build -t claude-yolo:latest "$SCRIPT_DIR" 2>&1 | tee -a "$LOGFILE"; then
    log_message "Error: Docker build failed. Please check the error messages above."
    exit 1
  fi
  log_message "Base image build complete!"
fi

# Check for project-specific configuration
if [ -f "$CONFIG_FILE" ]; then
  log_message "Found project configuration: .claude-yo.yml"

  # Validate the config file
  if ! validate_config "$CONFIG_FILE"; then
    exit 1
  fi

  # Generate project image name with hash for caching
  PROJECT_IMAGE=$(get_project_image_name "$MOUNTDIR")
  CONFIG_HASH=$(get_config_hash "$CONFIG_FILE")
  CACHE_TAG="${PROJECT_IMAGE}-${CONFIG_HASH}"

  # Handle rebuild of project image
  if [ "$REBUILD" = true ]; then
    log_message "Removing cached project image..."
    docker rmi "$CACHE_TAG" 2>&1 | tee -a "$LOGFILE" || true
  fi

  # Check if cached project image exists
  if [[ "$(docker images -q "$CACHE_TAG" 2> /dev/null)" == "" ]]; then
    log_message "Building project-specific image..."

    # Generate and build project Dockerfile
    TEMP_DOCKERFILE=$(mktemp)
    generate_project_dockerfile "$CONFIG_FILE" "$TEMP_DOCKERFILE"

    log_message "Generated Dockerfile:"
    cat "$TEMP_DOCKERFILE" | tee -a "$LOGFILE"
    log_message ""

    if ! docker build -t "$CACHE_TAG" -f "$TEMP_DOCKERFILE" "$SCRIPT_DIR" 2>&1 | tee -a "$LOGFILE"; then
      log_message ""
      log_message "═══════════════════════════════════════════════════════════════"
      log_message "Project-specific build failed. Common issues:"
      log_message "  - Package name typo (check apt/pip/npm package names)"
      log_message "  - Missing dependency (pip packages may need apt packages first)"
      log_message "  - Custom RUN command syntax error"
      log_message "═══════════════════════════════════════════════════════════════"
      rm "$TEMP_DOCKERFILE"
      exit 1
    fi

    rm "$TEMP_DOCKERFILE"

    # Clean up old cached images for this project (different hash)
    docker images --format '{{.Repository}}:{{.Tag}}' 2>/dev/null | \
      grep "^${PROJECT_IMAGE}-" | \
      grep -v "$CACHE_TAG" | \
      xargs -r docker rmi 2>/dev/null || true

    log_message "Project image built: $CACHE_TAG"
  else
    log_message "Using cached project image: $CACHE_TAG"
  fi

  DOCKER_IMAGE="$CACHE_TAG"
fi

# =============================================================================

# Log container setup information to file only (container will display on console)
# This avoids duplicate output since the container script always shows this info
{
  echo "═══════════════════════════════════════════════════════════════"
  echo "Container Setup"
  echo "═══════════════════════════════════════════════════════════════"
  echo "Container user:      $USERNAME"
  echo "UID:GID:             $USERID:$GROUPID"
  echo "Working directory:   $MOUNTDIR"
  echo "                     → mounted at /workspace"
  echo "═══════════════════════════════════════════════════════════════"
} >> "$LOGFILE"

# =============================================================================
# Common Container Script Components (to reduce duplication)
# =============================================================================

# User setup: find existing user with matching UID or create new user
# This script fragment is used inside the container to set up the user
CONTAINER_USER_SETUP='
  EXISTING_USER=$(getent passwd '"$USERID"' | cut -d: -f1)
  if [ -n "$EXISTING_USER" ]; then
    CONTAINER_USER=$EXISTING_USER
  else
    CONTAINER_USER='"$USERNAME"'
    groupadd -g '"$GROUPID"' $CONTAINER_USER 2>/dev/null || true
    useradd -u '"$USERID"' -g '"$GROUPID"' -m -s /bin/bash $CONTAINER_USER
  fi

  # Restore home directory from persistent volume if it exists
  if [ -d /home-persist/$CONTAINER_USER ]; then
    cp -a /home-persist/$CONTAINER_USER/. /home/$CONTAINER_USER/
  fi
'

# Container setup banner (shown after user is set up)
CONTAINER_BANNER='
  echo "═══════════════════════════════════════════════════════════════"
  echo "Container Setup Complete"
  echo "═══════════════════════════════════════════════════════════════"
  echo "Container user:      $CONTAINER_USER"
  echo "UID:GID:             '"$USERID"':'"$GROUPID"'"
  echo "Working directory:   '"$MOUNTDIR"'"
  echo "                     → mounted at /workspace"
  echo "═══════════════════════════════════════════════════════════════"
'

# Home directory save (run at the end of session)
CONTAINER_SAVE_HOME='
  mkdir -p /home-persist/$CONTAINER_USER
  cp -a /home/$CONTAINER_USER/. /home-persist/$CONTAINER_USER/
'

# Debug shell sequence (shown after Claude exits in debug mode)
CONTAINER_DEBUG_SHELL='
  echo ""
  echo "═══════════════════════════════════════════════════════════════"
  echo "Claude exited. Starting debug shell..."
  echo "═══════════════════════════════════════════════════════════════"
  echo "You are now in the container as $CONTAINER_USER"
  echo "Working directory: /workspace"
  echo ""
  echo "Type '\''exit'\'' to save your home directory and leave the container."
  echo "═══════════════════════════════════════════════════════════════"
  echo ""
  su -l $CONTAINER_USER
  echo "Saving authentication data..."
'

# =============================================================================

# Run the container (behavior depends on headless, debug, and verbose flags)
if [ "$HEADLESS" = true ]; then
  # Mode 5: Headless (no TTY, for cron/automation)
  log_message "Headless mode - running non-interactively"

  docker run \
    -v "$MOUNTDIR":/workspace \
    -v claude-yolo-home:/home-persist \
    --rm \
    "$DOCKER_IMAGE" \
    /bin/bash -c "$CONTAINER_USER_SETUP
      su - \$CONTAINER_USER -c \"cd /workspace && $CLAUDE_CMD\"
      EXIT_CODE=\$?
      $CONTAINER_SAVE_HOME
      exit \$EXIT_CODE
    "
elif [ "$DEBUG" = true ]; then
  if [ "$VERBOSE" = true ]; then
    # Mode 4: Debug + Verbose (persistent shell, full logging)
    log_message "Debug + Verbose mode enabled - full session logged, container persists"

    # Build the container script for debug+verbose mode
    DEBUG_VERBOSE_SCRIPT="$CONTAINER_USER_SETUP $CONTAINER_BANNER
        echo \"\"
        echo \"Press Enter to start Claude Code with --dangerously-skip-permissions\"
        read
        su - \$CONTAINER_USER -c \"cd /workspace && $CLAUDE_CMD\"
        $CONTAINER_DEBUG_SHELL
        $CONTAINER_SAVE_HOME
        echo \"Done. Exiting container.\"
      "

    if command -v script &> /dev/null; then
      script -q -f -c "docker run \
        -v \"$MOUNTDIR\":/workspace \
        -v claude-yolo-home:/home-persist \
        -it \
        --rm \
        \"$DOCKER_IMAGE\" \
        /bin/bash -c '$DEBUG_VERBOSE_SCRIPT'" "$LOGFILE"
    else
      # Fallback without script command
      log_message "Warning: 'script' command not found. Docker session output will not be logged."
      docker run \
        -v "$MOUNTDIR":/workspace \
        -v claude-yolo-home:/home-persist \
        -it \
        --rm \
        "$DOCKER_IMAGE" \
        /bin/bash -c "$DEBUG_VERBOSE_SCRIPT"
    fi
  else
    # Mode 3: Debug only (persistent shell, no full logging)
    log_message "Debug mode enabled - container will persist after Claude exits"

    docker run \
      -v "$MOUNTDIR":/workspace \
      -v claude-yolo-home:/home-persist \
      -it \
      --rm \
      "$DOCKER_IMAGE" \
      /bin/bash -c "$CONTAINER_USER_SETUP $CONTAINER_BANNER
        echo \"\"
        echo \"Press Enter to start Claude Code with --dangerously-skip-permissions\"
        read
        su - \$CONTAINER_USER -c \"cd /workspace && $CLAUDE_CMD\"
        $CONTAINER_DEBUG_SHELL
        $CONTAINER_SAVE_HOME
        echo \"Done. Exiting container.\"
      "
  fi
else
  if [ "$VERBOSE" = true ]; then
    # Mode 2: Verbose only (no persistent shell, full logging)
    log_message "Verbose mode enabled - full session will be logged"

    # Build the container script for verbose mode (with Enter prompt, no debug shell)
    VERBOSE_SCRIPT="$CONTAINER_USER_SETUP $CONTAINER_BANNER
        echo \"\"
        echo \"Press Enter to start Claude Code with --dangerously-skip-permissions\"
        read
        su - \$CONTAINER_USER -c \"cd /workspace && $CLAUDE_CMD\"
        $CONTAINER_SAVE_HOME
      "

    if command -v script &> /dev/null; then
      script -q -f -c "docker run \
        -v \"$MOUNTDIR\":/workspace \
        -v claude-yolo-home:/home-persist \
        -it \
        --rm \
        \"$DOCKER_IMAGE\" \
        /bin/bash -c '$VERBOSE_SCRIPT'" "$LOGFILE"
    else
      # Fallback without script command
      log_message "Warning: 'script' command not found. Docker session output will not be logged."
      docker run \
        -v "$MOUNTDIR":/workspace \
        -v claude-yolo-home:/home-persist \
        -it \
        --rm \
        "$DOCKER_IMAGE" \
        /bin/bash -c "$VERBOSE_SCRIPT"
    fi
  else
    # Mode 1: Default (no persistent shell, no full logging)
    docker run \
      -v "$MOUNTDIR":/workspace \
      -v claude-yolo-home:/home-persist \
      -it \
      --rm \
      "$DOCKER_IMAGE" \
      /bin/bash -c "$CONTAINER_USER_SETUP $CONTAINER_BANNER
        echo \"\"
        echo \"Starting Claude Code with --dangerously-skip-permissions...\"
        echo \"\"
        su - \$CONTAINER_USER -c \"cd /workspace && $CLAUDE_CMD\"
        $CONTAINER_SAVE_HOME
      "
  fi
fi
